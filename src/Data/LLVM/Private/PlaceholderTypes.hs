module Data.LLVM.Private.PlaceholderTypes ( Instruction(..)
                                          , InstructionT(..)
                                          , Constant(..)
                                          , ConstantT(..)
                                          , Module(..)
                                          , GlobalDeclaration(..)
                                          , BasicBlock(..)
                                          , FormalParameter(..)
                                          , Type(..)
                                          , PartialConstant
                                          , voidInst
                                          , namedInst
                                          , maybeNamedInst
                                          , valueRef
                                          ) where

import Data.ByteString.Char8 ( ByteString )
import Data.Hashable

import Data.LLVM.Private.AttributeTypes

-- These types are generated by the parser and will be
-- *temporary*.  They reference strings since that is all we have at
-- parse time.  These types will be replaced by direct references
-- after the entire AST is built and we can build the self-referential
-- graph structure.

data Instruction = Instruction { instName :: Maybe Identifier
                               , instType :: Type
                               , instContent :: InstructionT
                               , instMetadata :: Maybe Identifier
                               }
                   -- This variant is used if we can't build the type
                   -- yet.  It can be resolved after everything is
                   -- made properly referential.  This is useful for
                   -- getelementptr and extractvalue.
                 | UnresolvedInst { unresInstName :: Maybe Identifier
                                  , unresInstContent :: InstructionT
                                  , unresInstMetadata :: Maybe Identifier
                                  }
           deriving (Show, Eq)

type PartialConstant = Type -> Constant

voidInst :: InstructionT -> Instruction
voidInst v = Instruction { instName = Nothing
                         , instType = TypeVoid
                         , instContent = v
                         , instMetadata = Nothing
                         }

namedInst :: Identifier -> Type -> InstructionT -> Instruction
namedInst i t v = Instruction { instName = Just i
                              , instType = t
                              , instContent = v
                              , instMetadata = Nothing
                              }

maybeNamedInst :: Maybe Identifier -> Type -> InstructionT -> Instruction
maybeNamedInst i t v = Instruction { instName = i
                                   , instType = t
                                   , instContent = v
                                   , instMetadata = Nothing
                                   }

data Constant = ConstValue ConstantT Type
              | ValueRef Identifier
              deriving (Show, Eq)

instance Hashable Constant where
  hash (ConstValue ct t) = hash ct `combine` hash t
  hash (ValueRef ident) = hash ident

valueRef :: Identifier -> a -> Constant
valueRef ident = const (ValueRef ident)

-- The first group of value types are unusual and are *not* "users".
-- This distinction is not particularly important for my purposes,
-- though, so I'm just giving all values a list of operands (which
-- will be empty for these things)
data InstructionT = RetInst (Maybe Constant)
            | UnconditionalBranchInst Constant
            | BranchInst Constant Constant Constant
            | SwitchInst Constant Constant [(Constant, Constant)]
            | IndirectBranchInst Constant [Constant]
            | UnwindInst
            | UnreachableInst
            | AddInst [ArithFlag] Constant Constant
            | SubInst [ArithFlag] Constant Constant
            | MulInst [ArithFlag] Constant Constant
            | DivInst Constant Constant -- Does not encode the exact flag of sdiv.  Convince me to
            | RemInst Constant Constant
            | ShlInst Constant Constant
            | LshrInst Constant Constant
            | AshrInst Constant Constant
            | AndInst Constant Constant
            | OrInst Constant Constant
            | XorInst Constant Constant
            | ExtractElementInst Constant Constant
            | InsertElementInst Constant Constant Constant
            | ShuffleVectorInst Constant Constant Constant
            | ExtractValueInst Constant [Integer]
            | InsertValueInst Constant Constant [Integer]
            | AllocaInst Type Constant Integer -- Type, NumElems, align
            | LoadInst Bool Constant Integer -- Volatile? Type Dest align
            | StoreInst Bool Constant Constant Integer -- Volatile? Type Dest align
            | TruncInst Constant Type -- The value being truncated, and the type truncted to
            | ZExtInst Constant Type
            | SExtInst Constant Type
            | FPTruncInst Constant Type
            | FPExtInst Constant Type
            | FPToUIInst Constant Type
            | FPToSIInst Constant Type
            | UIToFPInst Constant Type
            | SIToFPInst Constant Type
            | PtrToIntInst Constant Type
            | IntToPtrInst Constant Type
            | BitcastInst Constant Type
            | ICmpInst ICmpCondition Constant Constant
            | FCmpInst FCmpCondition Constant Constant
            | PhiNode [(Constant, Constant)]
            | SelectInst Constant Constant Constant
            | GetElementPtrInst Bool Constant [Constant]
            | CallInst { callIsTail :: Bool
                       , callConvention :: CallingConvention
                       , callParamAttrs :: [ParamAttribute]
                       , callRetType :: Type
                       , callFunction :: Constant
                       , callArguments :: [(Constant, [ParamAttribute])]
                       , callAttrs :: [FunctionAttribute]
                       , callHasSRet :: Bool
                       }
            | InvokeInst { invokeConvention :: CallingConvention
                         , invokeParamAttrs :: [ParamAttribute]
                         , invokeRetType :: Type
                         , invokeFunction :: Constant
                         , invokeArguments :: [(Constant, [ParamAttribute])]
                         , invokeAttrs :: [FunctionAttribute]
                         , invokeNormalLabel :: Constant
                         , invokeUnwindLabel :: Constant
                         , invokeHasSRet :: Bool
                         }
            | VaArgInst Constant Type
            deriving (Show, Eq)

instance Hashable InstructionT where
  hash (RetInst c) = 1 `combine` hash c
  hash (UnconditionalBranchInst c) = 2 `combine` hash c
  hash (BranchInst c1 c2 c3) =
    3 `combine` hash c1 `combine` hash c2 `combine` hash c3
  hash (SwitchInst c1 c2 cs) =
    4 `combine` hash c1 `combine` hash c2 `combine` hash cs
  hash (IndirectBranchInst c cs) =
    5 `combine` hash c `combine` hash cs
  hash UnwindInst = 6
  hash UnreachableInst = 7
  hash (AddInst _ c1 c2) =
    8 `combine` hash c1 `combine` hash c2
  hash (SubInst _ c1 c2) =
    9 `combine` hash c1 `combine` hash c2
  hash (MulInst _ c1 c2) =
    10 `combine` hash c1 `combine` hash c2
  hash (DivInst c1 c2) =
    11 `combine` hash c1 `combine` hash c2
  hash (RemInst c1 c2) =
    12 `combine` hash c1 `combine` hash c2
  hash (ShlInst c1 c2) =
    13 `combine` hash c1 `combine` hash c2
  hash (LshrInst c1 c2) =
    14 `combine` hash c1 `combine` hash c2
  hash (AshrInst c1 c2) =
    15 `combine` hash c1 `combine` hash c2
  hash (AndInst c1 c2) =
    16 `combine` hash c1 `combine` hash c2
  hash (OrInst c1 c2) =
    17 `combine` hash c1 `combine` hash c2
  hash (XorInst c1 c2) =
    18 `combine` hash c1 `combine` hash c2
  hash (ExtractElementInst c1 c2) =
    19 `combine` hash c1 `combine` hash c2
  hash (InsertElementInst c1 c2 c3) =
    20 `combine` hash c1 `combine` hash c2 `combine` hash c3
  hash (ShuffleVectorInst c1 c2 c3) =
    21 `combine` hash c1 `combine` hash c2 `combine` hash c3
  hash (ExtractValueInst c is) =
    22 `combine` hash c `combine` hash is
  hash (InsertValueInst c1 c2 is) =
    23 `combine` hash c1 `combine` hash c2 `combine` hash is
  hash (AllocaInst t c i) =
    24 `combine` hash t `combine` hash c `combine` hash i
  hash (LoadInst b c i) =
    25 `combine` hash b `combine` hash c `combine` hash i
  hash (StoreInst b c1 c2 i) =
    26 `combine` hash b `combine` hash c1 `combine` hash c2 `combine` hash i
  hash (TruncInst c t) =
    27 `combine` hash c `combine` hash t
  hash (ZExtInst c t) = 28 `combine` hash c `combine` hash t
  hash (SExtInst c t) = 29 `combine` hash c `combine` hash t
  hash (FPTruncInst c t) = 30 `combine` hash c `combine` hash t
  hash (FPExtInst c t) = 31 `combine` hash c `combine` hash t
  hash (FPToUIInst c t) = 32 `combine` hash c `combine` hash t
  hash (FPToSIInst c t) = 33 `combine` hash c `combine` hash t
  hash (UIToFPInst c t) = 34 `combine` hash c `combine` hash t
  hash (SIToFPInst c t) = 35 `combine` hash c `combine` hash t
  hash (PtrToIntInst c t) = 36 `combine` hash c `combine` hash t
  hash (IntToPtrInst c t) = 37 `combine` hash c `combine` hash t
  hash (BitcastInst c t) = 38 `combine` hash c `combine` hash t
  hash (ICmpInst c c1 c2) =
    39 `combine` hash c `combine` hash c1 `combine` hash c2
  hash (FCmpInst c c1 c2) =
    40 `combine` hash c `combine` hash c1 `combine` hash c2
  hash (PhiNode cs) = 41 `combine` hash cs
  hash (SelectInst c1 c2 c3) =
    42 `combine` hash c1 `combine` hash c2 `combine` hash c3
  hash (GetElementPtrInst b c cs) =
    43 `combine` hash b `combine` hash c `combine` hash cs
  hash CallInst { callRetType = rt
                , callFunction = f
                } = 44 `combine` hash rt `combine` hash f
  hash InvokeInst { invokeRetType = rt
                  , invokeFunction = f
                  } = 45 `combine` hash rt `combine` hash f
  hash (VaArgInst c t) = 46 `combine` hash c `combine` hash t


data Module = Module DataLayout TargetTriple [GlobalDeclaration]
            deriving (Show, Eq)

-- Ident AddrSpace Annotations Type(aptr) Initializer alignment
data GlobalDeclaration = GlobalDeclaration Identifier Int LinkageType GlobalAnnotation Type (Maybe Constant) Integer (Maybe ByteString)
                       | GlobalAlias Identifier LinkageType VisibilityStyle Type Constant
                       | NamedType Identifier Type
                       | ModuleAssembly Assembly
                       | ExternalValueDecl Type Identifier
                       | ExternalFuncDecl Type Identifier [FunctionAttribute]
                       | NamedMetadata Identifier [Constant]
                       | UnnamedMetadata Identifier [Maybe Constant]
                       | FunctionDefinition { funcLinkage :: LinkageType
                                            , funcVisibility :: VisibilityStyle
                                            , funcCC :: CallingConvention
                                            , funcRetAttrs :: [ParamAttribute]
                                            , funcRetType :: Type
                                            , funcName :: Identifier
                                            , funcParams :: [FormalParameter]
                                            , funcAttrs :: [FunctionAttribute]
                                            , funcSection :: Maybe ByteString
                                            , funcAlign :: Integer
                                            , funcGCName :: Maybe GCName
                                            , funcBody :: [BasicBlock]
                                            , funcIsVararg :: Bool
                                            }
                         deriving (Show, Eq)

data FormalParameter = FormalParameter Type [ParamAttribute] Identifier
                     deriving (Show, Eq)

data ConstantT = BlockAddress Identifier Identifier -- Func Ident, Block Label -- to be resolved into something useful later
               | ConstantAggregateZero
               | ConstantArray [Constant] -- This should have some parameters but I don't know what
               | ConstantExpr InstructionT -- change this to something else maybe?  Value should suffice... might even eliminate this one
               | ConstantFP Double
               | ConstantInt Integer
               | ConstantString ByteString
               | ConstantPointerNull
               | ConstantStruct [Constant] -- Just a list of other constants
               | ConstantVector [Constant] -- again
               | UndefValue
               | MDNode [Maybe Constant] -- A list of constants (and other metadata)
               | MDString ByteString
               | GlobalVariable VisibilityStyle LinkageType ByteString
               | InlineAsm ByteString ByteString -- asm, constraints
               deriving (Show, Eq)

instance Hashable ConstantT where
  hash (BlockAddress i1 i2) = hash i1 `combine` hash i2
  hash ConstantAggregateZero = 234
  hash (ConstantArray cs) = hash cs
  hash (ConstantExpr i) = hash i
  hash (ConstantFP d) = hash d
  hash (ConstantInt i) = hash i
  hash (ConstantString s) = hash s
  hash ConstantPointerNull = 456
  hash (ConstantStruct cs) = hash cs
  hash (ConstantVector cs) = hash cs
  hash UndefValue = 678
  hash (MDNode mcs) = hash mcs
  hash (MDString bs) = hash bs
  hash (GlobalVariable vis lt s) = hash vis `combine` hash lt `combine` hash s
  hash (InlineAsm s1 s2) = hash s1 `combine` hash s2

data BasicBlock = BasicBlock (Maybe Identifier) [Instruction]
                deriving (Show, Eq)

data Type = TypeInteger Int -- bits
          | TypeFloat
          | TypeDouble
          | TypeFP128
          | TypeX86FP80
          | TypePPCFP128
          | TypeX86MMX
          | TypeVoid
          | TypeLabel
          | TypeMetadata
          | TypeArray Integer Type
          | TypeVector Integer Type
          | TypeFunction Type [Type] Bool -- Return type, arg types, vararg
          | TypeOpaque
          | TypePointer Type -- (Maybe Int) -- Address Space
          | TypeStruct [Type]
          | TypePackedStruct [Type]
          | TypeUpref Int
          | TypeNamed Identifier
          deriving (Show, Eq)

instance Hashable Type where
  hash (TypeInteger i) = 1 `combine` hash i
  hash TypeFloat = 2
  hash TypeDouble = 3
  hash TypeFP128 = 4
  hash TypeX86FP80 = 5
  hash TypePPCFP128 = 6
  hash TypeX86MMX = 7
  hash TypeVoid = 8
  hash TypeLabel = 9
  hash TypeMetadata = 10
  hash (TypeArray sz t) = 11 `combine` hash sz `combine` hash t
  hash (TypeVector sz t) = 12 `combine` hash sz `combine` hash t
  hash (TypeFunction t ts b) =
    13 `combine` hash t `combine` hash b `combine` hash ts
  hash TypeOpaque = 14
  hash (TypeStruct ts) = 15 `combine` hash ts
  hash (TypePackedStruct ts) = 16 `combine` hash ts
  hash (TypeUpref i) = 17 `combine` hash i
  hash (TypeNamed i) = hash i
